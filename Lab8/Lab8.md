# Тема 8. Введение в ООП.
## Отчет по Теме #8 выполнил:
- Морозов Семен Игоревич
- ПИЭ-21-2

| Задание | Лаб. раб. | Сам. раб. |
| ------ | ------ | ------ |
| Задание 1 | + | + |
| Задание 2 | + | + |
| Задание 3 | + | + |
| Задание 4 | + | + |
| Задание 5 | + | + |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Самостоятельная работа №1
### Самостоятельно создайте класс и его объект. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
## Выполнение:
```python
class Flat:
    def __init__(self, area, cost):
        self.area = area
        self.cost = cost

my_flat = Flat("80m2", "10,000$")
```
### Результат:
![Меню](https://github.com/kyorrr/Software_Engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/Lab8/pic/1.png)

## Вывод: Создал класс, инициализировал 2 атрибута.

## Задание №2
### Самостоятельно создайте атрибуты и методы для ранее созданного класса. Они должны отличаться, от тех, что указаны в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.
## Выполнение:
```python
class Flat:
    def __init__(self, area, cost):
        self.area = area
        self.cost = cost

    def sell(self):
        print(f'Покупаю квартиру площадью {self.area} и стоит она {self.cost}')

my_flat = Flat("80m2", "10,000$")
my_flat.sell()
```
### Результат:
![Меню](https://github.com/kyorrr/Software_Engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/Lab8/pic/2.png)


### Вывод: Дополнил первую работу, добавив новую функцию, которая выводит, какой площадью мы продаем квартиру и сколько она стоит.

## Задание №3
### Самостоятельно реализуйте наследование, продолжая работать с ранее созданным классом. Оно должно отличаться, от того, что указано в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли

## Выполнение:
```python
class Flat:
    def __init__(self, area, cost):
        self.area = area
        self.cost = cost

    def sell(self):
        print(f'Покупаю квартиру площадью {self.area} и стоит она {self.cost}')

class Apartment(Flat):
    def __init__(self, area, cost, place):
        super().__init__(area, cost)
        self.place = place

    def placement(self):
        print(f'Покупаю квартиру площадью {self.area}, '
              f'стоит она {self.cost} и находится по адресу {self.place}')

my_flat = Apartment("80m2", "10,000$", "Mira ST.")
my_flat.sell()
my_flat.placement()
```
### Результат:
![Меню](https://github.com/kyorrr/Software_Engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/Lab8/pic/3.png)

### Вывод: Использовано наследование для создания нового класса Apartment, который расширяет функциональность базового класса Book и добавляет новый атрибут 'place'.

## Задание №4
### Самостоятельно реализуйте инкапсуляцию, продолжая работать с ранее созданным классом. Она должна отличаться, от того, что указана в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

### Выполнение:
```python
class Flat:
    def __init__(self, area, cost):
        self._area = area
        self.__cost = cost

    def sell(self):
        print(f'Покупаю квартиру площадью {self._area} и стоит она {self.__cost}')

my_flat = Flat("80m2", "10,000$")
my_flat.sell()
print(my_flat._area)
```
## Результат:
![Меню](https://github.com/kyorrr/Software_Engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/Lab8/pic/4.png)

### Вывод: Атрибут 'area' сделал закрытым, а 'cost' - приватным. Подровнял под них программу и уже добавил в вевод площадь квартиры.

## Задание №5
### Самостоятельно реализуйте полиморфизм. Он должен отличаться, от того, что указан в теоретическом материале (методичке) и лабораторных заданиях. Результатом выполнения задания будет листинг кода и получившийся вывод консоли.

## Выполнение:
```python
class Cost:
    def cost(self):
        pass

class Flat(Cost):
    def __init__(self, area, placement):
        self.area = area
        self.placement = placement

    def cost(self):
        return self.area * 2 * self.placement * 1000

class Apartment(Cost):
    def __init__(self, area, placement):
        self.area = area
        self.placement = placement

    def cost(self):
        return self.area * 4 * self.placement * 1000


places = [Flat(62, 5), Apartment(80, 9)]
for place in places:
    print(place.cost())
```
### Результат:
![Меню](https://github.com/kyorrr/Software_Engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/Lab8/pic/5.png)
![Меню](https://github.com/kyorrr/Software_Engineering/blob/%D0%A2%D0%B5%D0%BC%D0%B0_8/Lab8/pic/5.1.png)

#### Вывод: Использован полиморфизм, где метод 'cost' представляет общий интерфейс для подсчета стоимости квартир, но каждый подкласс (Apartmnet и Flat) предоставляет свою уникальную реализацию этого метода.

## Общий вывод: 
Объектно-ориентированное программирование (ООП) в Python, как и в других языках программирования, предоставляет ряд преимуществ и инструментов для более удобной и эффективной разработки программ. Было не особо сложно.
